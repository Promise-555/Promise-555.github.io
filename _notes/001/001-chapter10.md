## 第10章 演绎论证II：真值函数逻辑

### 10.1　真值表和逻辑符号

#### 10.1.1　命题变元

在第9章中，我们用大写字母代表直言命题中的词项。在本章中，我们用大写字母代表命题。在接下来的讨论中，我们主要关注诸如“并非”“并且”“或者”等词语在命题中所起的作用，以及它们如何联结简单命题从而构成复合命题。请不要混淆：在第9章中，大写字母表示词项，在这里大写字母表示命题，所以这些字母被称为命题变元（claim variable）。

#### 10.1.2　真值表

在真值函数逻辑里，任何给定的命题P如果不是真的，就是假的，没有其他可能。下面的图表是真值表（truth table），它罗列了命题P的真值的两种可能情形（T表示真值为真，F表示真值为假）：

> ![真值表](media/image15.jpeg)

### 四种真值函数命题

可以利用真值表来定义真值函数符号：无论命题P的真值如何，其负命题或矛盾命题（用符号～P表示）的真值与之正好相反。因此，负命题（negation）的真值表为：

> ![负命题真值表](media/image16.jpeg)

因为任何给定的判断非真即假，所以对两个命题P和Q而言，其真值情形的四种组合分别为：P和Q二者都真、都假或它们的真值正好相反，其中一个为真，另一个为假。具体如下图所示：

> ![真值组合](media/image17.jpeg)

合取命题（conjunction）是由两个（被称为合取支的）简单命题构成的复合命题：当且仅当构成它的两个简单命题（合取支）都为真时，合取命题为真。合取命题的一个例子是“帕克在家而摩尔在工作”。符号“&”把两个合取支P、Q联结起来，表达“P且Q”。合取命题的真值表为：

> ![合取命题真值表](media/image18.jpeg)

析取命题（disjunction）是由两个（被称为析取支的）简单命题组成的复合命题。当且仅当两个析取支都假时，析取命题为假。例如：帕克在家或摩尔在工作。用符号来表达析取命题时，符号“∨”用来代表析取命题的连接词，自然语言中，与符号“∨”最贴近的词是“或”。析取命题的真值表为：

> ![析取命题真值表](media/image19.jpeg)

由两个简单命题构成的第三种复合命题是假言命题（conditional claim）。日常语言中，通常用词语“如果……那么……”来表述条件，例如：如果帕克在家，那么摩尔就在工作。用箭头符号“→”来表示假言命题的连接词，假言命题的符号形式是：P→Q。假言命题中的前一个简单命题，即P，是前件（antecedent），而第二个简单命题，即Q，是后件（consequent）。当且仅当前件为真而且后件为假时，假言命题为假。假言命题的真值表为：

> ![假言命题真值表](media/image20.jpeg)

假设摩尔向你承诺，如果他上午拿到薪水，中午就请客。这可以表达为假言命题：如果摩尔上午拿到薪水，那么他中午请客。我们可以分别用P（表示“摩尔上午拿到薪水”这个命题）和L（表示“摩尔中午请客”这个命题）及连接词符号把上述命题表达为：P→L。

为了理解假言命题的真值表，让我们问自己一个问题：在什么情况下摩尔违背了他的诺言？稍加思考你就会得出结论，在说摩尔违背诺言之前，必须有两件事发生。首先，他确实在今天上午领到了薪水（毕竟，他没有说如果没拿到薪水他也会这么做）。另外，他领到了薪水之后中午却没有请客。这两个条件加起来才使得摩尔最初的诺言为假。注意，在其他任何情况下，我们都不能说摩尔违背了他的诺言。这就是为什么假言命题的真值表中只有一种情况为假，该情形就是：前件为真而且后件为假。

### 总结

> ![真值函数命题总结](media/image21.jpeg)

复合命题形式中每增加一个字母，各命题变元的真值组合的可能性就要在以前的基础上加倍，真值表的行数也因此加倍。判断一个复合命题形式的真值表的行数的公式是r=2的n次方，其中r是表格的行数，n是命题形式中的字母数。

### 10.2　用符号表达复合命题

#### 10.2.1　“如果”与“仅当”

语词“如果”单独使用时，引入的就是假言命题的前件。语词“仅当”则引入假言命题的后件。

换言之：一个简单命题到底是假言命题的前件还是后件并不取决于其出现的位置，而是取决于联结它的逻辑连接词。例如：摩尔身上会湿的，如果帕克弄翻了船。该命题中含有“帕克”的部分是前件，虽然它出现在含有“摩尔”的部分之后。这个命题要表达的是：如果帕克弄翻了船，摩尔身上会湿。用符号来表达这个命题的形式就是：P→M，其中，“如果”引入的那个命题是前件。

再看下面的例子：帕克会买单，仅当摩尔击中9号球。这个命题就与前例不同了。该命题中，含有“帕克”的部分是前件，因为“仅当”联结的部分是假言命题的后件。这个命题与下述命题等值：如果帕克买单（P），那就是摩尔击中了9号球（M）。用括号里的字母来代表各简单命题，这个命题用符号也可表达为：P→M。

（这句话只保证了一件事：只要我们看到“帕克买单”这个结果发生，我们就可以100%地倒推出“摩尔一定击中了”。（因为没击中他绝对不买）它完全没有保证另一件事：如果摩尔击中了，帕克就一定会买单。（因为可能还有别的隐藏条件））

我们可以在假言命题的前件之前使用“如果”，也可以在假言判断的后件之前使用“仅当”；通过这两种方式所得到的是相互等值的命题。正如上述出现连接词“如果”的例子，由连接词“仅当”所联结的命题出现的位置并不重要，“摩尔身上会湿”尽管出现在命题的开端，但它是假言命题的后件；“仅当”所联结的“摩尔击中9号球”即使出现在句首，它也依然是假言命题的后件。仅当摩尔击中了9号球，帕克才会买单。这个命题的符号表达依然是：P→M。

综合关于“如果”和“仅当”这两个词语的经验，我们就不难用符号表达短语“当且仅当”“当且仅当”所联结的命题既是前件又是后件。P当且仅当Q就表达为：（P→Q） & （Q→P）

当然，还有其他联结假言命题的词语。“只要”在引出假言命题的前件时，跟词语“如果”的作用是一样的。对于命题“摩尔将买这辆车，只要销售者赠送他足够的零备件”，若用“如果”来替换其中的“只要”，那么所得的命题与这个命题等值。

#### 10.2.2　必要条件和充分条件

人们在提及假言命题的时候往往会考虑必要条件和充分条件。如：要引起燃烧必须有氧气存在。这就是说，没有氧气就不会产生燃烧，或者说，如果要引起燃烧（C）就必须提供氧气（O）。需要注意的是，必要条件是假言命题的后件：C→O。（没它不行）

充分条件是确保某事发生的条件。出生于美国就是成为美国公民的充分条件——仅凭这一点，一个人就可以成为美国公民。充分条件是假言命题的前件，所以“如果胡安于美国出生（B），那么胡安是美国公民（C）”表达为：B→C。（有它就行）

正如必要条件和充分条件之间不仅相互区分，也相互联系一样，“如果”和“仅当”之间也是既相互区分，又相互联系。词语“如果”只联结充分条件，短语“仅当”则只联结必要条件。所以，命题“X是Y的必要条件”应该表达为：Y→X。

往往会出现如下情形：一事物既是另一事物的必要条件，也是它的充分条件。比如：如果简支付她在全国符号逻辑学会的会费，她就可以延续会员资格（支付会费是充分条件），而且，不支付会费她就无法延续会员资格（支付会费又是必要条件）。那么，我们可以将此表述为“当且仅当简支付会费（M），她能延续全国逻辑学会的会员资格（D）”，用符号表达就是：（M→D） & （D→M）。

#### 10.2.3　“除非”

若要用符号表达命题“波拉将取消赎回权，除非昆西付清全款”，我们可以把它写成～Q→P，因为原命题和“如果昆西没付清全款，那么波拉会取消赎回权”是等值的。但更为简便的是，看看～Q→P的真值表是什么。如果你已经熟悉基本真值表，你就会发现它的真值表和P∨Q的是一样的。实际上，你完全可以把词语“除非”视为“或”，用符号“∨”来表示。

#### 10.2.4　“或者……或者”

有时我们需要准确地知道一个析取命题从哪里开始，词语“或者”就能给我们提供这方面的指引。比较下面两个命题：或者P和Q，或者RP且或者Q或者R。这两个命题所陈述的不同，它们的真值表也不同，它们之间唯一的区别就在于词语“或者”的位置；忽略这个词，命题就是模棱两可的。“或者”告诉我们第一个析取命题从P开始，而第二个命题中的析取命题从Q开始。所以第一个命题用符号表达为（P & Q）∨R，而第二个命题用符号表达为P & （Q∨R）。

在假言命题中，词语“如果”所起的作用和“或者”在析取命题中所起的作用是一样的。注意下面两个命题的区别：P且如果Q那么R如果P且Q那么R“如果”告诉我们，第一个命题中的前件是Q，而第二个命题中的前件是P且Q。这两个命题的符号表达分别是：P & （Q→R）P & Q→R

### 10.3　真值函数论证模式（简版）

### 10.4　真值函数论证（详版）

让我们先复习一下“有效”这个概念。当且仅当前提为真能保证结论为真时，一个论证是有效的——也就是说，如果其前提为真，结论就不可能为假（记住，我们并不关注前提实际是否为真）。

#### 10.4.1　真值表法

例子：将有大量北极气团（A）流向中西部，除非急流（J）向南移动。可惜，急流不可能向南移动，所以，北极气团将流向中西部。用符号表达为：

> ![符号表达示例](media/image22.jpeg)

这个论证的真值表为：

> ![真值表示例](media/image23.jpeg)

我们要知道这个论证是否有效，就要看有无可能其前提为真而结论为假，如果有这样的可能性，那么在真值表中会表现出来，因为真值表罗列了命题变元A和J真值组合的所有可能情况。该真值表只有在第二行里，前提都是真的，检查该行中的结论A就会发现，在该行里结论也是真的。因此，没有这样一种可能，其中前提为真而结论为假。所以该论证是有效的。

下面是一个复杂些的例子：如果斯嘉丽在该案中有罪，那么怀特夫人肯定没有锁后门并且上校肯定在十点之前就就寝了。然而，或者怀特夫人锁了后门，或者上校在十点之前并没有就寝。因此，斯嘉丽无罪。为表示这个论证的形式，我们用字母表示简单命题：S=斯嘉丽在该案中有罪。W=怀特夫人没有锁后门。C=上校在十点之前就寝。用符号来表达这个论证：

> ![复杂论证符号表达](media/image24.jpeg)

让我们仔细思考一下这个论证。你在阅读的时候，请参考前面用符号来表达命题的部分。注意第一个命题是假言命题，前件为“斯嘉丽在该案中有罪”，后件是一个合取命题。回想一下合取命题的真值表就会发现，要想使得该合取命题为真，“怀特夫人没有锁后门”和“上校在十点之前就寝”必须都为真。而第二个前提是一个析取命题，它告诉我们或者怀特夫人锁了后门或者上校在十点前并没有就寝。但是如果这两个析取支中有一个或两个是真的，那么前面的合取命题中就至少有一个支判断是假的，所以不会出现合取判断的支判断都真的情况。这就意味着符号W & C所表达的合取命题一定为假，即假言前提的后件是假的。在这种情况下，怎样才能使假言前提为真呢？唯有其前件也为假，也就是说，结论“斯嘉丽无罪”肯定是真的。

只要填好了真值表，评估论证是否有效就简单了。我们只要看是否能找出前提为真而结论为假的行，只要能发现哪怕一行，就足以证明论证无效。该例中，我们发现只在真值表的最后三行中前提都是真的，而这几行里，结论也是真的。所以不存在这种情况——真值表里没有这样一行——其中前提都为真而结论为假。因此，该论证是有效的。

> ![复杂论证真值表](media/image25.jpeg)

#### 10.4.2　简化真值表法

判定真值函数论证有效或无效的简单易行方法就是简化真值表法。该方法背后的理念是：如果一个论证是无效的，那么在论证的真值表中至少有一行使得前提为真而结论为假。简化真值表法就是直接去寻找真值表中的这一行。请看下面的论证形式：

> ![论证形式示例](media/image26.jpeg)

先看论证的结论：结论是假言命题，只有一种方法使其为假，即使其前件为真而后件为假。为满足这一点，就要令P和R都为假。在结论为假的条件下能让两个前提都真吗？只要Q为真，就可以满足这一点。也就是：

> ![简化真值表法示例](media/image27.jpeg)

命题变元的这种真值组合使得两个前提都真而结论为假，因而证明了这个论证是无效的。我们不必烦琐地创建整个真值表而只需给出与证明论证无效相关的一行。如果论证是有效的，我们就无法找到这样一行。

下面说明针对有效的论证如何运用这种方法：

> ![有效论证示例](media/image28.jpeg)

使得该论证结论为假的唯一方法是让S为真而R为假。所以要做如下赋值：

> ![赋值示例1](media/image29.jpeg)

既然S为真，为使第二个前提为真就要Q为真。由此继续赋值：

> ![赋值示例2](media/image30.jpeg)

但基于上述真值，根本不可能使得第一个命题为真，因为P∨Q为真（既然Q为真）而R为假。因为除上述赋值方法外，没有其他方法使得结论为假而第二个前提为真，又因为这唯一的赋值方法无法使得第一个前提为真，所以我们就能得出结论：该论证有效。

有时候，可能有不止一种方法让论证的结论为假。例如：

> ![多种赋值可能示例](media/image31.jpeg)

该论证无效，自己证明吧。

通常，真值表里有不止一行使得前提为真而结论为假，其中任何一行都可以证明论证无效。不要形成错误的观念：即仅仅因为有一行前提都真而且结论也真，就认为结论能从前提中推出，即论证有效。要证明论证有效，必须是所有前提为真的行中，结论都为真。

### 10.5　演绎

我们下面所关注的方法在证明论证无效上作用甚微，但该方法在证明论证有效方面有优势，这个方法就是演绎（deductions）。运用演绎方法，实际上就是通过一系列基本真值函数有效论证模式从前提推出结论。仿佛“在头脑里过一遍”该论证，逐步探究，假设所有前提都真，如何得出最终结论。

#### 10.5.1　第一组规则：有效论证的基本模式

规则1：分离规则（MP），也称肯定前件式

这种模式的任何论证都是有效的。

> ![分离规则](media/image32.jpeg)

如果前提之一是假言命题，而另一个前提是第一个假言命题的前件，那么，根据分离规则，就可以从这两个前提中推出假言命题的后件作为结论。作为假言命题的构成部分的命题不必是简单字母——如果在P的位置上是一些更复杂的表达式，如（P∨R），只要在上述模式中P出现的任何地方都是该复合表达式，就还是上面的推理模式。如：

> ![分离规则示例](media/image33.jpeg)

该推理就是，如果在演绎的一行中有一个假言命题，而另一行是这个假言命题的前件，那就可以在新的一行中记下该假言命题的后件。

如果上述假言命题的后件是该论证的结论，那么，演绎推理就完成了——结论已经得出。如果它还不是你所关注的论证的结论，那么，该假言命题的后件可以作为推出你所寻找的结论的另一个前提。例如：

> ![演绎推理示例](media/image34.jpeg)

我们给论证的三个前提标上了数字，把结论放在旁边（此后，我们将用一根斜线和三个点［／∴］来代替“所以”，作为结论的提示词）。注意，第一行是一个假言命题，第三行是它的前件。分离规则允许我们写下第一行的后件作为我们演绎中新的一行：4. R 1，3，MP

这一行右边所标的是推理规则的缩写以及规则所作用的各前提，这些标注被称为演绎的注解。接着我们可以利用该演绎中新的一行来得出我们最初寻找的结论，即S。5. S 2，4，MP

我们再次使用了分离规则，这次是通过第二行和第四行得出结论的。对于我们是如何得出这个结论的，也在右侧做了标注以解释。

请注意分离规则的准确适用。可以对其运用分离规则的假言命题必须是独立的，如果假言命题只是某复合命题的支命题，就不能对其运用MP规则。比如：

> ![分离规则错误应用示例](media/image35.jpeg)

这就是不规范地运用MP规则。第一行的确有一个支命题是假言命题，第二行也的确是第一行的假言命题的前件，但分离规则不能运用到作为支命题的假言命题之上。

规则2：否定后件式（MT）

否定后件式的推理模式如下：如果一个前提是假言命题，而另一前提否定该假言命题的后件，那就可以写出假言命题的前件的否定作为演绎的结论。

> ![否定后件式](media/image36.jpeg)

下面的演绎推理运用了前面两条规则：

> ![否定后件式示例](media/image37.jpeg)

规则3：连锁论证式（CA）

若前提中的两个命题都是假言命题，而且一个假言命题的前件正好是另一个假言命题的后件，连锁论证（chain argument）规则就允许你从这两个假言命题中推导出一个假言命题做结论。

> ![连锁论证式](media/image38.jpeg)

规则4：析取论证式（DA）

一个前提是析取命题，另一个前提否定其中一个析取支，则可以推出另一个析取支。

> ![析取论证式](media/image39.jpeg)

规则5：合取分解式（SIM）

如果合取命题是真的，那么合取支一定都是真的。因而，以一个合取命题为前提可以演绎地推出任意一个合取支为结论。

> ![合取分解式](media/image40.jpeg)

规则6：合取合成式（CONJ）

这条规则允许你从前提中推出一个合取命题作为结论，该结论由各前提作为合取支构成。

> ![合取合成式](media/image41.jpeg)

规则7：析取附加式（ADD）

显然，无论P和Q代表什么命题，只要P是真的，或者P或者Q一定为真。一个析取支为真则整个析取命题为真。

> ![析取附加式](media/image42.jpeg)

规则8：两难推理的构成式（CD）

以两个假言命题和它们的前件的析取为前提可以推导出一个析取命题为结论，结论的析取支分别是上述两个假言命题的后件。

> ![两难推理的构成式](media/image43.jpeg)

规则9：两难推理的破坏式（DD）

以两个假言命题和它们的后件的否定的析取为前提可以推导出一个析取命题为结论，结论的析取支分别是上述两个假言命题的前件的否定。

> ![两难推理的破坏式](media/image44.jpeg)

#### 10.5.2　第二组规则：真值函数的等值式

本组规则与第一组规则之间有如下重要区分。首先，本组规则的表达式都是真值函数的等值式。也就是说，每一条规则中都含有两个虽然表达形式不同但真值完全相同的符号形式。我们用双向箭头↔来表示可以从其中任意一个推出另一个（第一组规则只允许单方向的推导：从前提到结论）。其次，本组规则中相互等值的表达式之间可以相互替换。如果在演绎中有一个合取支，而且本组规则表明其中一个合取支与某其他表达式等值，我们就可以用后者替换前者。看完例证后我们将会明白如何进行真值替换。

运用第二组规则的总原则是：相互等值的命题之间可以相互替换。与第一组规则一样，本组规则中，只要每条规则中相同字母所表达的判断总是相同的，P、Q等就可以作为任意一个判断的符号。

规则10：双重否定律（DN）

P↔ ～～P

规则10表明，无论对于简单命题还是复合命题，我们可以在任意一个命题前添加或删除两个否定符号。该规则允许我们在下述两个表达式之间相互推导：P→（Q∨R） P→～～（Q∨R）

因为规则10保证表达式（Q∨R）与其双重否定～～（Q∨R）相互等值，这进而保证P→（Q∨R）与P→～～（Q∨R）相互等值，所以这两个表达式之间相互蕴涵。

下面是运用DN规则的实例：

> ![双重否定律示例](media/image45.jpeg)

规则11：交换律（COM）

（P & Q）↔（Q & P）（P∨Q）↔（Q∨P）

规则11允许任意一个合取命题或析取命题的支判断“交换位置”，从而使得复合命题中的支命题出现的顺序正好相反。

例如：P→（Q∨R）　　　P→（R∨Q）注意这里只在支命题中，即假言命题的后件中运用了交换规则。

规则12：蕴涵析取律（IMPL）

（P→Q）↔（～P∨Q）规则12允许依据需要将假言命题转换为相应的选言命题，反之亦然。下面的例子是规则12的运用：（P∨Q）→R ↔ ～（P∨Q）∨R

规则13：假言易位律（CONTR）

（P→Q）↔（～Q→ ～P）在第9章中我们学习过直言命题的换质位运算，规则13就是真值函数版的换质位运算。该规则允许我们将假言命题前后件的位置互换，但要分别在前后件的前面加上或去掉否定符号。如：（P & Q）→（P∨Q）↔ ～（P∨Q）→ ～（P & Q）在上面的例子中，等值式的一端前后件前都有否定符号，另一端前后件前都没有否定符号。

假言命题的前件或后件中有而且只有一个带否定符号时，依然可以运用规则13，不过需要采取两个步骤，先运用双重否定规则，再进行假言易位。如：足够熟练后，也可以将上述两步合并为一个步骤。

> ![假言易位律示例](media/image46.jpeg)

规则14：德摩根定律（DEM）

～（P & Q）↔（～P∨～Q）～（P∨Q）↔（～P & ～Q）注意，当否定符号从括号前移到括号内时，“&”就要变成“∨”，反之亦然。注意，在德摩根定律中，否定符号的运算与代数中的负号不同。注意当你将～（P∨Q）中的否定符号移到括号内时，所得到的不是（～P∨～Q），在运用德摩根定律时，将否定符号移到括号内的同时，要将合取连接词与析取连接词互换。你可以把～（P∨Q）和（～P&～Q）读为“非P且非Q”，可以将～（P & Q）和（～P∨～Q）读为“并非P且Q”。

规则15：条件移出律（EXP）

（P→（Q→R））↔（（P & Q）→ R）

用自然语言表达，条件移出律的意思是，“如果P，那么如果Q，那么R”等值于“如果P且Q，那么R”。

规则16：结合律（ASSOC）

（（P & （Q & R）↔（P & Q） & R）（（P∨Q）∨R）↔（P∨Q）∨R）

结合律告诉我们，当用析取符号或合取符号联结三个变项时，变项之间如何组合是无关紧要的。当一个析取命题的析取支多于两个时，依然是只要其中一个析取支为真，整个命题就为真；一个合取命题无论有几个合取支，要使得合取命题为真，就必须使每个合取支都真。

规则17：分配律（DIST）

（P & （Q∨R）↔（P & Q）∨（P & R）P∨（Q & R）↔（（P∨Q） & （P∨R）

规则17允许我们将合取支分配到析取命题之中，或者将析取支分配到合取命题中。

规则18：重言式（TAUT）

（P∨P）↔P（P & P）↔P

下面的两个例子是对第一组规则和第二组规则的综合运用。

> ![综合运用示例1](media/image47.jpeg)

> ![综合运用示例2](media/image48.jpeg)

真值函数的演绎规则

> ![真值函数演绎规则](media/image49.jpeg)

#### 10.5.3　条件证明

条件证明（conditional proof，CP）既是一条规则，也是构建演绎推论的策略。如果我们要构建关于假言命题P→Q的演绎推论，我们证明的是什么呢，我们证明的是“如果P为真，那么Q也为真”。实现这个目标的方法之一就是假设P为真（也就是说把P作为附加的前提），然后证明在这个假设基础上Q也必定为真。如果我们能做到这一点——在假设P为真之后证明了Q也为真——那么，我们也就证明了如果P那么Q，或者是P→Q。

使用CP作为新规则的方法是：在给定的前提之后，直接记下我们想要证明的假言命题的前件，并给推理串的这个步骤的编码画上圈；在该行的注释中，标明“CP前提”。下面就是范例：

> ![条件证明示例1](media/image50.jpeg)

在证明了所需要的假言命题的后件之后，写下整个假言命题。然后，在推理串左边的空白处画上一条线，把画圈的前提和我们由此推出后件的那一行连接起来。证明过程

> ![条件证明示例2](media/image51.jpeg)

一旦我们得出了假言命题～P→R，就不再依赖CP前提，所以我们在推理串左边空白处从CP前提到由之推出的最后一步画上连接线，表明消除了这个设定的前提。

下面是运用CP规则的一些重要规定：

1. CP只能用于推出假言命题：在消去CP前提以后，接下来的一步必须是假言命题，它以其在先的步骤为后件，以CP前提为前件（注意：许多命题和假言命题都是等价的。比如，要得到（～P∨Q），只要先证明（P→Q），然后运用用蕴涵析取律IMPL）。
2. 如果在推理中不止一次运用CP规则——也就是说，如果引入不止一个CP前提，它们必须以与引入假设相反的顺序依次消去。这意味着从不同的CP前提处引出的消除假设前提的线不能互相交叉。看下面的例子。
3. 一旦一个CP前提被消去，从该前提推导出的任何步骤——那些步骤被左边空白处画的线包围起来——就都不能再用于该演绎推理了。（它们依赖于CP前提，而且，它已经被消去了。）
4. 所有的CP前提都必须被消去。

下面运用CP的例子中，有两个附加的前提是假设的，并且以相反的顺序被消去。

> ![条件证明示例3](media/image52.jpeg)

注意，在第5步加上的附加前提在第8步完成的时候消去了，而第10步完成的时候把第3步的前提消去了。再一次注意：无论何时消去假设前提，你必须让这个命题成为演绎推理中下一步中假言命题的前件（你可以尝试不使用CP来完成前面的演绎，你会庆幸可以运用这个规则，虽然看上去掌握这条规则有些困难，但使用CP让许多演绎推论简化易行）。

再看一些运用规则CP的实例。

> ![条件证明示例4](media/image53.jpeg)

> ![条件证明示例5](media/image54.jpeg)

> ![条件证明示例6](media/image55.jpeg)

在结束本章之前，我们应该指出真值函数逻辑体系的两个理论意义重大的特征：可靠性和完全性。

一个逻辑系统是可靠的（对我们这里的目的而言这是最重要的），就是指按照该系统的规则构造的每一个演绎推理都是有效的论证。换句话说就是，没有一个或一系列演绎推理会让我们从真的句子开始，却以假的句子结束。

说一个体系是完全的，是指对于任何一个（或者可能的）有效的论证而言，都可以通过该系统的规则，从论证的前提演绎出论证的结论。也就是说，如果结论C的确可以从前提P和Q中有效地推出，那么一定可以构建这样的演绎推理，该推理从P和Q开始，以C结束。

